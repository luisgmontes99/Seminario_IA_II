# -*- coding: utf-8 -*-
"""Proyeto_Final_Zoo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LfOu8ex15Ydj8V-PTFt-AxyB3fnrHcFp
"""

#LIBRERIAS EN GENERAL
import pandas as pd
import statsmodels.api as sm
import numpy as np
import warnings
import matplotlib.pyplot as plt

import tensorflow as tf
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler,MinMaxScaler, LabelEncoder
#Modelos Establecidos
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn import svm
# Suprimir todos los warnings
warnings.filterwarnings("ignore")

#Librerias de las metricas
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.metrics import accuracy_score, precision_score,recall_score,f1_score

df = pd.read_csv('/content/Zoo.csv')
df.hist()

"""# *REGRESION LOGISTICA*

---

"""

# DataFrame Animales
df = pd.read_csv('/content/Zoo.csv')
df = df.dropna(subset=['Tipo'])
X = df.drop(['Nombre','Tipo'],axis=1)
y = df[['Tipo']]

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15,random_state=19)

# Escalar características
scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Modelo
classifier = LogisticRegression()
classifier.fit(X_train, y_train)
# Realizar predicciones
y_pred = classifier.predict(X_test)
# Graficar el histograma
plt.hist(y_pred, bins=20)
plt.xlabel('Clase')
plt.ylabel('Frecuencia')
plt.title('Regresion Logistica')
plt.show()
#-------------------CALCULO DE METRICAS--------------------
precision = precision_score(y_test, y_pred, average='weighted')
recall = recall_score(y_test, y_pred, average='weighted')
f1 = f1_score(y_test, y_pred, average='weighted')
accuracy = accuracy_score(y_test,y_pred)
#---ESPECIFICITY
conf_matrix =confusion_matrix(y_test,y_pred)
tn, fp, fn, tp = conf_matrix.ravel()[:4]
specificity = tn / (tn + fp)
#---
# Mostrar los resultados
print('Precision: {:.2f}'.format(precision))
print('Accuracy: {:.2f}'.format(accuracy))
print('Sensitivity (Recall): {:.2f}'.format(recall))
print('F1 Score: {:.2f}'.format(f1))
print('Specificity: {:.2f}'.format(specificity))

"""# *K-Vecinos Cercanos*

---

"""

# DataFrame Animales
df = pd.read_csv('/content/Zoo.csv')
#df = df.dropna(subset=['ID'])
X = df.drop(['Nombre','Tipo'],axis=1)
y = df[['Tipo']]
# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15,random_state=19)
# Escalar características (si es necesario)
scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
#MODELO DE CLASIFICADOR
n_neighbors = 7
knn = KNeighborsClassifier(n_neighbors)
knn.fit(X_train, y_train)
y_pred = knn.predict(X_test)
pred_series = pd.Series(y_pred)
# Graficar el histograma
plt.hist(pred_series, bins=15)  # Puedes ajustar el número de bins según tu preferencia
plt.xlabel('Clases')
plt.ylabel('Frecuencia')
plt.title('K-Vecinos Cercanos')
plt.show()
#-------------------CALCULO DE METRICAS--------------------
precision = precision_score(y_test, y_pred, average='weighted')
recall = recall_score(y_test, y_pred, average='weighted')
f1 = f1_score(y_test, y_pred, average='weighted')
accuracy = accuracy_score(y_test,y_pred)
#---ESPECIFITY
conf_matrix =confusion_matrix(y_test,y_pred)
tn, fp, fn, tp = conf_matrix.ravel()[:4]
specificity = tn / (tn + fp)
#---
# Mostrar los resultados
print('Precision: {:.2f}'.format(precision))
print('Accuracy: {:.2f}'.format(accuracy))
print('Sensitivity (Recall): {:.2f}'.format(recall))
print('F1 Score: {:.2f}'.format(f1))
print('Specificity: {:.2f}'.format(specificity))

"""# *Máquinas de Vectores de Soporte*

---

"""

# DataFrame Animales
df = pd.read_csv('/content/Zoo.csv')
#df = df.dropna(subset=['ID'])
X = df.drop(['Nombre','Tipo'],axis=1)
y = df[['Tipo']]
#df.hist()
# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15,random_state=19)
# Escalar características (si es necesario)
scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
#MODELO DE CLASIFICADOR
svm_classifier = svm.SVC(kernel='linear')
svm_classifier.fit(X_train, y_train)
y_pred = svm_classifier.predict(X_test)
pred_series = pd.Series(y_pred)
# Graficar el histograma
plt.hist(pred_series,bins=15)  # Puedes ajustar el número de bins según tu preferencia
plt.xlabel('Clases')
plt.ylabel('Frecuencia')
plt.title('Maquinas de vector de soporte')
plt.show()
#-------------------CALCULO DE METRICAS--------------------
precision = precision_score(y_test, y_pred, average='weighted')
recall = recall_score(y_test, y_pred, average='weighted')
f1 = f1_score(y_test, y_pred, average='weighted')
accuracy = accuracy_score(y_test,y_pred)
#---ESPECIFITY
conf_matrix =confusion_matrix(y_test,y_pred)
tn, fp, fn, tp = conf_matrix.ravel()[:4]
specificity = tn / (tn + fp)
#---
# Mostrar los resultados
print('Precision: {:.2f}'.format(precision))
print('Accuracy: {:.2f}'.format(accuracy))
print('Sensitivity (Recall): {:.2f}'.format(recall))
print('F1 Score: {:.2f}'.format(f1))
print('Specificity: {:.2f}'.format(specificity))

"""# *Naive Bayes*

---

"""

# DataFrame Animales
df = pd.read_csv('/content/Zoo.csv')
#df = df.dropna(subset=['ID'])
X = df.drop(['Nombre','Tipo'],axis=1)
y = df[['Tipo']]
#df.hist()
# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15,random_state=19)
# Escalar características (si es necesario)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
#MODELO DE CLASIFICADOR
model = GaussianNB()
model.fit(X, y);
yprob = model.predict_proba(X_test)
y_pred = model.predict(X_test)
pred_series = pd.Series(y_pred)
# Graficar el histograma
plt.hist(pred_series, bins=15)  # Puedes ajustar el número de bins según tu preferencia
plt.xlabel('Clases')
plt.ylabel('Frecuencia')
plt.title('Naive Bayes')
plt.show()
#-------------------CALCULO DE METRICAS--------------------
precision = precision_score(y_test, y_pred, average='weighted')
recall = recall_score(y_test, y_pred, average='weighted')
f1 = f1_score(y_test, y_pred, average='weighted')
accuracy = accuracy_score(y_test,y_pred)
#---ESPECIFITY
conf_matrix =confusion_matrix(y_test,y_pred)
tn, fp, fn, tp = conf_matrix.ravel()[:4]
specificity = tn / (tn + fp)
#---
# Mostrar los resultados
print('Precision: {:.2f}'.format(precision))
print('Accuracy: {:.2f}'.format(accuracy))
print('Sensitivity (Recall): {:.2f}'.format(recall))
print('F1 Score: {:.2f}'.format(f1))
print('Specificity: {:.2f}'.format(specificity))

"""# *Red Neuronal con Tensorflow*

---
"""

# DataFrame Animales
df = pd.read_csv('/content/Zoo.csv')
#df = df.dropna(subset=['ID'])
X = df.drop(['Nombre','Tipo'],axis=1)
y = df[['Tipo']]
#df.hist()
# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.15,random_state=19)
# Escalar características (si es necesario)
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)
#MODELO DE CLASIFICADOR
mlp = MLPClassifier(hidden_layer_sizes=(100, 50), max_iter=2000)
mlp.fit(X_train, y_train)
# Hacer predicciones
y_pred = mlp.predict(X_test)
pred_series = pd.Series(y_pred)
# Graficar el histograma
plt.hist(pred_series, bins=15)  # Puedes ajustar el número de bins según tu preferencia
plt.xlabel('Clases')
plt.ylabel('Frecuencia')
plt.title('Red de Tensorflow')
plt.show()
#-------------------CALCULO DE METRICAS--------------------
precision = precision_score(y_test, y_pred, average='weighted')
recall = recall_score(y_test, y_pred, average='weighted')
f1 = f1_score(y_test, y_pred, average='weighted')
accuracy = accuracy_score(y_test,y_pred)
#---ESPECIFITY
conf_matrix =confusion_matrix(y_test,y_pred)
tn, fp, fn, tp = conf_matrix.ravel()[:4]
specificity = tn / (tn + fp)
#---
# Mostrar los resultados
print('Precision: {:.2f}'.format(precision))
print('Accuracy: {:.2f}'.format(accuracy))
print('Sensitivity (Recall): {:.2f}'.format(recall))
print('F1 Score: {:.2f}'.format(f1))
print('Specificity: {:.2f}'.format(specificity))